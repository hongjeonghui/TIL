# DRF N:1 Relation 학습 기록

## 1. DRF에서의 N:1 관계 개념 정리

Django REST Framework에서 N:1 관계는 Comment(댓글)가 Article(게시글)을 참조하는 구조를 의미한다.  
댓글 여러 개(N)가 하나의 게시글(1)에 연결되는 구조로, 이를 기반으로 API를 구성하고 직렬화하며 응답 데이터를 제어하는 방법을 학습했다.

---

## 2. URL 및 HTTP Method 구조

| URL | GET | POST | PUT | DELETE |
| --- | --- | --- | --- | --- |
| comments/ | 댓글 목록 조회 |  |  |  |
| comments/1/ | 단일 댓글 조회 |  | 단일 댓글 수정 | 단일 댓글 삭제 |
| articles/1/comments/ |  | 댓글 생성 |  |  |

각 URL이 수행하는 기능을 명확하게 분리함으로써 RESTful API 구조를 따른다.

---

## 3. GET - 댓글 목록 조회 (List)

### Serializer 정의

```python
# articles/serializers.py
class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields = '__all__'
```

### URL

```python
path('comments/', views.comment_list),
```

### View

```python
@api_view(['GET'])
def comment_list(request):
    comments = Comment.objects.all()
    serializer = CommentSerializer(comments, many=True)
    return Response(serializer.data)
```

---

## 4. GET - 단일 댓글 조회 (Detail)

### URL

```python
path('comments/<int:comment_pk>/', views.comment_detail),
```

### View

```python
@api_view(['GET'])
def comment_detail(request, comment_pk):
    comment = Comment.objects.get(pk=comment_pk)
    serializer = CommentSerializer(comment)
    return Response(serializer.data)
```

---

## 5. POST - 댓글 생성

### URL

```python
path('articles/<int:article_pk>/comments/', views.comment_create),
```

### View

```python
@api_view(['POST'])
def comment_create(request, article_pk):
    article = Article.objects.get(pk=article_pk)
    serializer = CommentSerializer(data=request.data)
    if serializer.is_valid(raise_exception=True):
        serializer.save(article=article)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

### 왜 오류(400)가 발생했는가?

CommentSerializer는 원래 `article` 필드도 입력받아야 한다고 판단하지만  
POST 요청에서는 article 값을 주지 않는다.  
따라서 article 필드를 **읽기 전용 필드**로 처리해야 함.

### 읽기 전용 필드 설정

```python
class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields = '__all__'
        read_only_fields = ('article',)
```

---

## 6. 읽기 전용 필드 개념 정리

- 조회 시에는 보여주지만, 생성/수정 시 클라이언트로부터 입력받지 않는다.
- 유효성 검사에서 제외된다.
- 서버에서 직접 값을 주입해야 하는 필드는 반드시 read_only_fields로 설정해야 한다.
- 그렇지 않으면 DRF는 해당 필드가 누락됐다고 판단해 400 에러를 발생시킨다.

---

## 7. PUT / DELETE - 단일 댓글 수정 및 삭제

### View

```python
@api_view(['GET', 'PUT', 'DELETE'])
def comment_detail(request, comment_pk):
    comment = Comment.objects.get(pk=comment_pk)

    if request.method == 'GET':
        serializer = CommentSerializer(comment)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = CommentSerializer(comment, data=request.data)
        if serializer.is_valid(raise_exception=True):
            serializer.save()
            return Response(serializer.data)

    elif request.method == 'DELETE':
        comment.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

---

## 8. 응답 데이터 재구성 (article title 표시)

기본적으로 CommentSerializer의 article 필드는 Article의 id만 응답한다.  
하지만 article의 제목(title)을 응답하고 싶을 때는 별도의 Serializer가 필요하다.

### CommentSerializer 내부에서 article 필드 재정의

```python
class CommentSerializer(serializers.ModelSerializer):
    class ArticleTitleSerializer(serializers.ModelSerializer):
        class Meta:
            model = Article
            fields = ('title',)

    article = ArticleTitleSerializer(read_only=True)

    class Meta:
        model = Comment
        fields = '__all__'
```

### 핵심 포인트

- 기존 필드를 재정의한 경우 `read_only_fields`는 작동하지 않는다.
- 이때는 article 재정의 필드에 직접 `read_only=True`를 작성해야 한다.

---

## 9. 역참조(comment_set) 활용하여 단일 게시글에 댓글 목록 붙이기

Article → Comment 관계에서 Article은 comment_set을 갖는다.

### ArticleSerializer에 nested serializer 추가

```python
class ArticleSerializer(serializers.ModelSerializer):
    class CommentDetailSerializer(serializers.ModelSerializer):
        class Meta:
            model = Comment
            fields = ('id', 'content')

    comment_set = CommentDetailSerializer(many=True, read_only=True)

    class Meta:
        model = Article
        fields = '__all__'
```

이제 단일 게시글 조회 시 댓글 목록이 함께 포함된다.

---

## 10. 단일 게시글에 댓글 개수도 함께 넣기

Article 모델에는 댓글 개수 필드가 없다.  
따라서 댓글 수를 직접 계산해야 한다.

### View에서 annotate 적용

```python
article = Article.objects.annotate(num_of_comments=Count('comment')).get(pk=article_pk)
```

이렇게 하면 article 인스턴스에 num_of_comments라는 임시 필드가 추가된다.

---

## 11. annotate 필드를 serializer에서 사용하기 (SerializerMethodField)

annotate로 만들어진 필드는 실제 모델 필드가 아니므로  
serializer의 fields='__all__' 로는 포함되지 않는다.

따라서 SerializerMethodField를 사용한다.

### 구현

```python
class ArticleSerializer(serializers.ModelSerializer):
    num_of_comments = serializers.SerializerMethodField()

    class Meta:
        model = Article
        fields = '__all__'

    def get_num_of_comments(self, obj):
        return obj.num_of_comments
```

---

## 12. SerializerMethodField 상세 정리

- 새로운 값(가공된 데이터)을 응답에 포함시키고 싶을 때 사용.
- 읽기 전용.
- View에서 data를 조작할 필요 없이 Serializer에서 직접 응답 형태를 정의할 수 있음.

예시

```python
class UserSerializer(serializers.ModelSerializer):
    full_name = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = ('id', 'username', 'full_name', 'email')

    def get_full_name(self, obj):
        return f'{obj.first_name} {obj.last_name}'
```

---

## 13. 역참조 이름을 직접 바꾸었다면?

예를 들어 Comment 모델의 ForeignKey를 다음처럼 정의한다면:

```python
article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name='reviews')
```

그 경우 Serializer, annotate에서도 전부 다음처럼 사용해야 한다.

```python
reviews = CommentDetailSerializer(many=True, read_only=True)
Count('reviews')
```

---

## 14. API 문서화 - drf-spectacular

### 설치

```
pip install drf-spectacular
```

### settings.py 등록

```python
INSTALLED_APPS = [
    ...,
    'drf_spectacular',
]
```

```python
REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}
```

### URL 설정

```python
path('api/schema/swagger-ui/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
path('api/schema/redoc/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),
```

Swagger UI와 ReDoc 페이지에서 API 문서 자동 생성 확인 가능.

---

# 오늘 학습 핵심 요약

- N:1 관계에서 foreign key 처리 방식  
- read_only_fields가 필요한 이유  
- 필드 재정의 시 read_only 인자 직접 설정 필요  
- comment_set으로 역참조된 댓글 목록 출력  
- annotate + SerializerMethodField로 댓글 개수 응답  
- drf-spectacular로 API 문서 자동화  
