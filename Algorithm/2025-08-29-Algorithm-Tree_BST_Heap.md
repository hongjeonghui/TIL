# ğŸŒ³ TIL: íŠ¸ë¦¬ ìˆœíšŒ Â· ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST) Â· í™(Heap) 

---

## 1) ì—°ìŠµë¬¸ì œ: ì „ìœ„ ìˆœíšŒ (Pre-order Traversal) âœï¸

ì „ìœ„ ìˆœíšŒ: **ë£¨íŠ¸ â†’ ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½**

### ì•„ì´ë””ì–´
- ê°„ì„  ì •ë³´ë¥¼ `(ë¶€ëª¨ p, ìì‹ c)` ìŒìœ¼ë¡œ ë°›ì•„ `left[]`, `right[]`, `par[]` ë°°ì—´ì„ êµ¬ì„±
- `par[i] == 0`ì¸ ë…¸ë“œê°€ **ë£¨íŠ¸**
- ì „ìœ„ ìˆœíšŒ í•¨ìˆ˜ `pre_order(T)`ë¥¼ ì¬ê·€ë¡œ êµ¬í˜„

### êµ¬í˜„ (ë°°ì—´ ê¸°ë°˜ ì´ì§„íŠ¸ë¦¬)
```python
def pre_order(T):
    if T > 0:
        print(T, end=' ')        # visited(T)
        pre_order(left[T])       # pre_order(T.left)
        pre_order(right[T])      # pre_order(T.right)

# ì…ë ¥ ì˜ˆì‹œ
# V = ì •ì  ìˆ˜ (1~V ë²ˆí˜¸)
# arr = (p1 c1 p2 c2 ... p(E) c(E)) (E = V-1)
V = int(input().strip())
E = V - 1
arr = list(map(int, input().split()))

left  = [0] * (V + 1)
right = [0] * (V + 1)
par   = [0] * (V + 1)

for i in range(E):
    p, c = arr[i*2], arr[i*2 + 1]
    par[c] = p
    if left[p] == 0:
        left[p] = c
    else:
        right[p] = c

root = 1
for i in range(1, V + 1):
    if par[i] == 0:  # ë¶€ëª¨ê°€ ì—†ìŒ â†’ ë£¨íŠ¸
        root = i
        break

pre_order(root)
print()
```

---

## 2) ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST: Binary Search Tree) ğŸ”

### ì •ì˜
- **ì •ë ¬ ê·œì¹™**: `ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬`
- ëª¨ë“  ë…¸ë“œëŠ” **ì„œë¡œ ë‹¤ë¥¸ ìœ ì¼ í‚¤**
- **ì¤‘ìœ„(in-order) ìˆœíšŒ** ê²°ê³¼ê°€ **ì˜¤ë¦„ì°¨ìˆœ** ì •ë ¬

### íƒìƒ‰(ê²€ìƒ‰) ì•Œê³ ë¦¬ì¦˜
1. ë£¨íŠ¸ì—ì„œ ì‹œì‘
2. ì°¾ì„ ê°’ `x`ì™€ í˜„ì¬ ë…¸ë“œ í‚¤ ë¹„êµ  
   - `x == key` â†’ ì„±ê³µ  
   - `x < key` â†’ **ì™¼ìª½**ìœ¼ë¡œ ì§„í–‰  
   - `x > key` â†’ **ì˜¤ë¥¸ìª½**ìœ¼ë¡œ ì§„í–‰  
3. `None`(ì—†ìŒ)ê¹Œì§€ ë‚´ë ¤ê°€ë©´ ì‹¤íŒ¨

### ì‚½ì… ì•Œê³ ë¦¬ì¦˜
1. **íƒìƒ‰**ìœ¼ë¡œ ë‚´ë ¤ê°€ë©° ë“¤ì–´ê°ˆ ìœ„ì¹˜ ì°¾ê¸°
2. ì‹¤íŒ¨ê°€ ê²°ì •ëœ ê·¸ ì§€ì ì— ìƒˆ ë…¸ë“œ ì‚½ì…
> **ë™ì¼ í‚¤ëŠ” ì‚½ì… ë¶ˆê°€** (ë¬¸ì œì—ì„œ "ëª¨ë“  ì›ì†ŒëŠ” ìœ ì¼ í‚¤" ì¡°ê±´)

### ì‚­ì œ ì•Œê³ ë¦¬ì¦˜ (ì„¸ ê²½ìš°)
1. **ìì‹ 0ê°œ(ë¦¬í”„)**: ê·¸ëƒ¥ ì œê±°
2. **ìì‹ 1ê°œ**: ìì‹ì„ ë¶€ëª¨ì— **ì§ì ‘ ì—°ê²°**
3. **ìì‹ 2ê°œ**:  
   - **ëŒ€ì²´ ë…¸ë“œ**ë¥¼ ì„ íƒ: (1) ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ **ìµœì†Ÿê°’** or (2) ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ **ìµœëŒ“ê°’**
   - í˜„ì¬ ë…¸ë“œ ê°’ì„ ëŒ€ì²´ ë…¸ë“œ ê°’ìœ¼ë¡œ ë°”ê¾¸ê³ , **ëŒ€ì²´ ë…¸ë“œ**ë¥¼ (1) ë˜ëŠ” (2)ì˜ ê·œì¹™ìœ¼ë¡œ ì‚­ì œ

### ë³µì¡ë„ ë¹„êµí‘œ
| êµ¬ì¡°/ì•Œê³ ë¦¬ì¦˜ | íƒìƒ‰ | ì‚½ì… | ì‚­ì œ | ë¹„ê³  |
|---|---:|---:|---:|---|
| ë°°ì—´(ìˆœì°¨ ê²€ìƒ‰) | O(N) | - | - | ì •ë ¬ X |
| ì •ë ¬ëœ ë°°ì—´ + ì´ì§„íƒìƒ‰ | **O(log N)** | O(N) | O(N) | ì‚½ì…/ì‚­ì œ ë¹„ìš© í¼ |
| **BST (í‰ê· )** | **O(log N)** | **O(log N)** | **O(log N)** | ê· í˜•ì¼ ë•Œ |
| **BST (ìµœì•…)** | O(N) | O(N) | O(N) | í•œìª½ìœ¼ë¡œ ê¸°ì›€ |
| í•´ì‹œ | **O(1)** | **O(1)** | **O(1)** | ì¶”ê°€ ë©”ëª¨ë¦¬ í•„ìš” |

### íŒŒì´ì¬ ê°„ë‹¨ êµ¬í˜„ 
```python
class Node:
    __slots__ = ("key", "left", "right")
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def bst_insert(root, key):
    if root is None:
        return Node(key)
    if key < root.key:
        root.left = bst_insert(root.left, key)
    elif key > root.key:
        root.right = bst_insert(root.right, key)
    return root  # ë™ì¼ í‚¤ëŠ” ë¬´ì‹œ

def bst_search(root, key):
    if root is None or root.key == key:
        return root
    return bst_search(root.left, key) if key < root.key else bst_search(root.right, key)

def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=' ')
        inorder(root.right)

# í…ŒìŠ¤íŠ¸
nums = [8, 4, 12, 2, 6, 10, 14, 5]
root = None
for x in nums:
    root = bst_insert(root, x)
inorder(root)  # 2 4 5 6 8 10 12 14
print()
```

---

## 3) í™ (Heap) 

### ì •ì˜
- **ì™„ì „ ì´ì§„ íŠ¸ë¦¬** ê¸°ë°˜ì˜ **ìš°ì„ ìˆœìœ„** ìë£Œêµ¬ì¡°
- **ìµœëŒ€ í™**: ë¶€ëª¨ â‰¥ ìì‹ â†’ **ë£¨íŠ¸ = ìµœëŒ€ê°’**
- **ìµœì†Œ í™**: ë¶€ëª¨ â‰¤ ìì‹ â†’ **ë£¨íŠ¸ = ìµœì†Œê°’**

### ì—°ì‚° ì›ë¦¬
- **ì‚½ì…(enq)**: ë§¨ ë§ˆì§€ë§‰ ìë¦¬ì— ë„£ê³  **ë¶€ëª¨ì™€ ë¹„êµí•˜ë©° ìœ„ë¡œ(ìƒí–¥) êµí™˜(Heapify-up)**
- **ì‚­ì œ(deq)**: **ë£¨íŠ¸ ì œê±° â†’ ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë£¨íŠ¸ë¡œ ì˜¬ë¦¼ â†’ ìì‹ê³¼ ë¹„êµí•˜ë©° ì•„ë˜ë¡œ(í•˜í–¥) êµí™˜(Heapify-down)**  
  (í™ì—ì„œëŠ” **ë£¨íŠ¸ë§Œ ì‚­ì œ** ê°€ëŠ¥)

### ë³µì¡ë„
- ì‚½ì…/ì‚­ì œ: **O(log N)** (íŠ¸ë¦¬ ë†’ì´ë§Œí¼ ì´ë™)
- ìµœëŒ“ê°’/ìµœì†Ÿê°’ ì¡°íšŒ: **O(1)** (ë£¨íŠ¸ ì°¸ì¡°)

---

## 4) ì‹¤ìŠµ: ë°°ì—´ë¡œ êµ¬í˜„í•œ **ìµœëŒ€ í™** (1ë²ˆ ì¸ë±ìŠ¤ë¶€í„° ì‚¬ìš©)


```python
# ìµœëŒ€ í™ êµ¬í˜„ (ë°°ì—´ ì¸ë±ìŠ¤ 1ë¶€í„° ì‚¬ìš©)
heap = [0] * 101  # ì¶©ë¶„í•œ í¬ê¸°
last = 0          # í™ì— ë“¤ì–´ìˆëŠ” ë§ˆì§€ë§‰ ì¸ë±ìŠ¤

def enq(n):
    global last
    last += 1
    heap[last] = n
    c = last
    p = c // 2
    # ìƒí–¥ ì´ë™ (ë¶€ëª¨ < ìì‹ì´ë©´ êµí™˜) â†’ ìµœëŒ€ í™
    while p > 0 and heap[p] < heap[c]:
        heap[p], heap[c] = heap[c], heap[p]
        c = p
        p = c // 2

def deq():
    global last
    if last == 0:
        raise IndexError("deq from empty heap")
    # ë£¨íŠ¸ ë°±ì—…
    root_val = heap[1]
    # ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ ì˜¬ë¦¬ê³  last ê°ì†Œ
    heap[1] = heap[last]
    last -= 1

    # í•˜í–¥ ì´ë™ (ë¶€ëª¨ < ë” í° ìì‹ â†’ êµí™˜)
    p = 1
    c = p * 2
    while c <= last:
        # ì˜¤ë¥¸ìª½ ìì‹ì´ ì¡´ì¬í•˜ê³  ë” í¬ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
        if c + 1 <= last and heap[c] < heap[c + 1]:
            c += 1
        # ìì‹ì´ ë¶€ëª¨ë³´ë‹¤ í¬ë©´ êµí™˜
        if heap[p] < heap[c]:
            heap[p], heap[c] = heap[c], heap[p]
            p = c
            c = p * 2
        else:
            break
    return root_val

# ì‚¬ìš© ì˜ˆì‹œ
for x in [2, 5, 7, 3, 4, 6]:
    enq(x)

print("í™ ë‚´ë¶€(1~last):", heap[1:last+1])  # level-order ìƒíƒœ í™•ì¸

# ìµœëŒ“ê°’ë¶€í„° êº¼ë‚´ê¸°
popped = []
while last > 0:
    popped.append(deq())
print("êº¼ë‚¸ ìˆœì„œ(ë‚´ë¦¼ì°¨ìˆœ):", popped)  # [7, 6, 5, 4, 3, 2]
```

---

## 5) BST vs ë¦¬ìŠ¤íŠ¸ vs í™: ì–¸ì œ ë¬´ì—‡ì„ ì“°ë‚˜? ğŸ¤”

- **ì •ë ¬ ìœ ì§€ + ë¹ ë¥¸ ê²€ìƒ‰**ì´ í•„ìš”í•˜ë©´ â†’ **BST(ë˜ëŠ” ê· í˜• íŠ¸ë¦¬/íŠ¸ë¦½/ë ˆë“œë¸”ë™/AVL)**  
  - ì¤‘ìœ„ìˆœíšŒë¡œ **ì •ë ¬ëœ ìˆœíšŒ**ê°€ í•„ìš”í•  ë•Œ íŠ¹íˆ ìœ ë¦¬
- **ìµœëŒ“ê°’/ìµœì†Ÿê°’ì„ ìì£¼ êº¼ëƒ„** â†’ **í™**  
  - `k`ë²ˆì§¸ í° ê°’ ìœ í˜•, ìš°ì„ ìˆœìœ„ í, ìŠ¤ì¼€ì¤„ë§
- **ë‹¨ìˆœ ì €ì¥/ì „ì²´ ìˆœíšŒ** â†’ **ë¦¬ìŠ¤íŠ¸**  
  - ì‚½ì…/ì‚­ì œ ìœ„ì¹˜ ì œì•½ ì ê³  êµ¬í˜„ ê°„ë‹¨

---

## 6) ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ & ë””ë²„ê¹… í¬ì¸íŠ¸ 

- ì „ìœ„ìˆœíšŒ ì—°ìŠµ ì½”ë“œ
  - `root`ë¥¼ ì°¾ì•˜ìœ¼ë©´ **ë°˜ë“œì‹œ `pre_order(root)` í˜¸ì¶œ**í•´ì•¼ ì¶œë ¥ë¨
  - `left[p]`ê°€ ë¹„ì–´ìˆì„ ë•Œë§Œ ì™¼ìª½ì— ë°°ì¹˜, ì•„ë‹ˆë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ (í˜„ì¬ ë¡œì§ OK)
- í™ `deq()` êµ¬í˜„
  - `last = -1` âŒ â†’ **`last -= 1`**  
  - ìŠ¤ì™‘ ì˜¤íƒ€: `heap[p], heap[c] = heap[c]. heap[p]` âŒ â†’ **`,`ë¡œ ìŠ¤ì™‘**  
  - while ì¡°ê±´ì—ì„œ **ê²½ê³„ ì²´í¬** (`c <= last`, `c+1 <= last`) í•„ìˆ˜
- BST
  - **ì¤‘ë³µ í‚¤** í—ˆìš© ì•ˆ í•¨(ë¬¸ì œ ì •ì˜)
  - ìµœì•…ì˜ ê²½ìš°(í¸í–¥ íŠ¸ë¦¬) ì„±ëŠ¥ ì €í•˜ â†’ **ê· í˜• ê¸°ë²•** ê³ ë ¤

---

## 7) í•µì‹¬ ìš”ì•½ 

- **ì „ìœ„ ìˆœíšŒ**: ë£¨íŠ¸-ì™¼-ì˜¤ â†’ ì¬ê·€ ê¸°ë³¸í˜• ê¼­ ìˆ™ì§€
- **BST**: í‰ê·  **O(log N)**, ì¤‘ìœ„ ìˆœíšŒ = ì˜¤ë¦„ì°¨ìˆœ, **ì‚­ì œ 3ì¼€ì´ìŠ¤** í•„ìˆ˜ ì•”ê¸°
- **í™**: ì™„ì „ ì´ì§„ íŠ¸ë¦¬, **ë£¨íŠ¸ê°€ ìµœëŒ“/ìµœì†Ÿ**, ì‚½ì…/ì‚­ì œ **O(log N)**

## 8) ì •ë¦¬

1. **íŠ¸ë¦¬(Tree)**: ë¹„ì„ í˜• ìë£Œêµ¬ì¡°, ê·¸ë˜í”„ì˜ ì¼ì¢…. ë…¸ë“œë“¤ ê°„ ê³„ì¸µ ê´€ê³„ë¥¼ í‘œí˜„  
2. **ì´ì§„ íŠ¸ë¦¬(Binary Tree)**: ë…¸ë“œê°€ ìµœëŒ€ 2ê°œ ìì‹, ì™„ì „Â·í¬í™”Â·í¸í–¥ ë“± í˜•íƒœ  
3. **íŠ¸ë¦¬ ìˆœíšŒ(Traversal)**: ì „ìœ„Â·ì¤‘ìœ„Â·í›„ìœ„ ë“±, ëª¨ë“  ë…¸ë“œë¥¼ ë¹ ì§ì—†ì´ ë°©ë¬¸  
4. **ì´ì§„ íŠ¸ë¦¬ í‘œí˜„**: ë°°ì—´ ì¸ë±ìŠ¤ ë°©ì‹ / ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë°©ì‹  
5. **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)**: ì™¼ìª½ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½, ì¤‘ìœ„ ìˆœíšŒ ì‹œ ì˜¤ë¦„ì°¨ìˆœ, íƒìƒ‰/ì‚½ì…/ì‚­ì œ í‰ê·  $O(\log n)$  
6. **í™(Heap)**: ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì—ì„œ ìµœëŒ€/ìµœì†Œê°’ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì¶”ì¶œ, ìš°ì„ ìˆœìœ„ í êµ¬í˜„ì— í™œìš©  


