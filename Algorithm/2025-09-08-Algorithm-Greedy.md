# 📘 TIL: 조합적 문제 & 탐욕 알고리즘

## 1. 조합적 문제 (Combinatorics)

### 부분집합 (Powerset)

-   **정의**: 어떤 집합의 모든 원소에 대해, 공집합과 자기 자신을 포함한
    모든 집합\
-   원소 개수가 `n`개일 때 부분집합의 개수 = `2^n`

#### 구현 방법

1.  **완전 탐색 (재귀)**

    ``` python
    name = ['MIN', 'CO', 'TIM']

    def recur(cnt, subset):
        if cnt == len(name):
            print(subset)
            return
        # 포함하는 경우
        recur(cnt + 1, subset + [name[cnt]])
        # 포함하지 않는 경우
        recur(cnt + 1, subset)

    recur(0, [])
    ```

        출력 예시:
        ['MIN', 'CO', 'TIM']
        ['MIN', 'CO']
        ['MIN', 'TIM']
        ['MIN']
        ['CO', 'TIM']
        ['CO']
        ['TIM']
        []

2.  **바이너리 카운팅 (Bitmask)**

    ``` python
    arr = ['A', 'B', 'C']
    n = len(arr)

    for i in range(1 << n):   # 0 ~ 2^n - 1
        subset = []
        for j in range(n):
            if i & (1 << j):  # j번째 비트가 1이면 포함
                subset.append(arr[j])
        print(subset)
    ```

------------------------------------------------------------------------

### 조합 (Combination)

-   **정의**: 서로 다른 n개 중 r개를 **순서 없이** 선택
-   **순열(Permutation)**은 순서 중요 / 조합은 순서 없음

#### 구현 코드

``` python
arr = ['A', 'B', 'C', 'D', 'E']
N = 3
path = []

def recur(cnt, start):
    if cnt == N:
        print(path)
        return
    for i in range(start, len(arr)):
        path.append(arr[i])
        recur(cnt + 1, i + 1)
        path.pop()

recur(0, 0)
```

------------------------------------------------------------------------

## 2. 탐욕 알고리즘 (Greedy Algorithm)

### 개념

-   **현재 순간 가장 좋아 보이는 선택**을 반복하면서 문제 해결
-   빠르고 단순하지만, 항상 최적해 보장은 ❌

#### 탐욕 알고리즘 조건

1.  **탐욕적 선택 속성 (Greedy Choice Property)**
    -   각 단계의 최적 선택이 이후 선택에 영향을 주지 않음
2.  **최적 부분 구조 (Optimal Substructure)**
    -   부분 문제들의 최적해를 합치면 전체 최적해가 됨

------------------------------------------------------------------------

### 예시 1: 동전 교환 문제

-   목표: 최소 개수의 동전으로 거스름돈 지급
-   조건: 동전 단위가 배수 관계일 때만 탐욕이 최적 보장

``` python
coins = [500, 100, 50, 10]
amount = 1730
result = 0

coins.sort(reverse=True)  # 큰 단위부터
for c in coins:
    cnt = amount // c
    result += cnt
    amount -= cnt * c

print(result)  # 500x3 + 100x2 + 10x3 → 8개
```

------------------------------------------------------------------------

### 예시 2: 화장실 문제

-   한 명씩 차례대로 들어가야 할 때, **짧게 쓰는 사람 먼저** → 전체 대기
    시간 최소화

------------------------------------------------------------------------

### 예시 3: 배낭 문제 (Knapsack)

1.  **0-1 Knapsack**: 물건을 쪼갤 수 없음 → 탐욕으로는 항상 최적 X (DP
    필요)
2.  **Fractional Knapsack**: 물건 쪼갤 수 있음 → 무게당 가치가 큰 것부터
    담으면 항상 최적

------------------------------------------------------------------------

### 예시 4: 회의실 배정

-   가능한 많은 회의를 하려면?\
    → **종료 시간이 가장 빠른 회의**부터 선택

------------------------------------------------------------------------

### 대표적인 Greedy 활용 알고리즘

| 알고리즘                | 문제 유형   | 설명                          |
|--------------------------|-------------|-------------------------------|
| **동전 교환**           | 거스름돈    | 큰 단위 동전부터 사용         |
| **Fractional Knapsack** | 배낭 문제   | 무게 대비 가치 큰 것부터 선택 |
| **Prim / Kruskal**      | 그래프      | 최소 스패닝 트리(MST)         |
| **Dijkstra**            | 최단 경로   | 가까운 정점부터 확정          |


------------------------------------------------------------------------

## 3. 최종 정리

1.  **순열 vs 부분집합 vs 조합**
    -   부분집합: 모든 경우의 수 (2\^n)
    -   조합: 순서 없이 선택
    -   순열: 순서 있게 나열
2.  **탐욕 알고리즘**
    -   현재 순간 최적 선택 → 전체 문제 해결
    -   조건 충족 시 최적 보장
    -   그렇지 않으면 **DP/백트래킹** 필요

👉 핵심: **"이 문제는 Greedy가 통하는가?"** 를 먼저 판단하는 것이
중요하다.
