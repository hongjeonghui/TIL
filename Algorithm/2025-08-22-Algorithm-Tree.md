# 🌳 트리(Tree)

## 1. 트리의 개념

-   **비선형 구조**: 원소들 간 1:n 관계를 가지며, 계층적 구조를 표현
-   **계층형 자료구조**: 상위 원소에서 하위 원소로 확장되는 구조
-   **사이클 없음**: 트리는 사이클이 없는 무향 연결 그래프의 한 종류
-   한 노드에서 다른 노드로 가는 경로는 **유일**

------------------------------------------------------------------------

## 2. 트리의 정의

-   한 개 이상의 노드로 이루어진 유한 집합
-   조건:
    1.  최상위 노드를 **루트(root)**라 함
    2.  나머지 노드들은 분리된 서브트리(Subtree)로 구성 (재귀적 정의)

------------------------------------------------------------------------

## 3. 트리 용어 정리

-   **노드(Node)**: 트리의 원소
-   **간선(Edge)**: 부모와 자식을 연결하는 선
-   **루트(Root)**: 트리의 시작 노드
-   **형제(Sibling)**: 같은 부모를 가진 노드들
-   **조상(Ancestor)**: 어떤 노드에서 루트까지의 경로에 존재하는 모든
    노드
-   **자손(Descendant)**: 특정 노드의 서브트리에 속한 노드들
-   **차수(Degree)**
    -   노드의 차수: 자식 노드 수
    -   트리의 차수: 모든 노드 차수 중 최댓값
-   **리프(Leaf)**: 차수가 0인 노드 (자식 없음)
-   **노드 높이(Height of Node)**: 루트에서 해당 노드까지의 간선 수
-   **트리 높이(Height of Tree)**: 트리 내 노드들의 높이 중 최댓값

------------------------------------------------------------------------

## 4. 이진 트리(Binary Tree)

-   각 노드가 **최대 2개의 자식 노드**를 가질 수 있음
    -   왼쪽 자식(Left child), 오른쪽 자식(Right child)
-   레벨 `i`에서 최대 노드 수는 `2^i`개
-   높이가 `h`인 이진 트리의 노드 개수:
    -   최소: `h+1`개
    -   최대: `2^(h+1) - 1`개

### 4.1 이진 트리의 종류

1.  **포화 이진 트리 (Full Binary Tree)**
    -   모든 레벨이 노드로 가득 참
    -   노드 개수 = `2^(h+1) - 1`
2.  **완전 이진 트리 (Complete Binary Tree)**
    -   마지막 레벨을 제외하면 포화 상태
    -   마지막 레벨도 왼쪽부터 빈 자리 없이 채워짐
3.  **편향 이진 트리 (Skewed Binary Tree)**
    -   모든 노드가 한쪽 자식만 가짐
    -   왼쪽 편향 / 오른쪽 편향

------------------------------------------------------------------------

## 5. 트리의 순회(Traversal)

트리의 모든 노드를 중복 없이 방문하는 방법

-   **전위 순회(Preorder, VLR)**: Root → Left → Right
-   **중위 순회(Inorder, LVR)**: Left → Root → Right
-   **후위 순회(Postorder, LRV)**: Left → Right → Root

### 5.1 알고리즘 (Python)

``` python
def preorder_traverse(T):   # 전위 순회
    if T:
        visit(T)
        preorder_traverse(T.left)
        preorder_traverse(T.right)

def inorder_traverse(T):    # 중위 순회
    if T:
        inorder_traverse(T.left)
        visit(T)
        inorder_traverse(T.right)

def postorder_traverse(T):  # 후위 순회
    if T:
        postorder_traverse(T.left)
        postorder_traverse(T.right)
        visit(T)
```

### 5.2 예시

        A
       / \
      B   C
     / \    \
    D   E    F

-   전위: A B D E C F
-   중위: D B E A C F
-   후위: D E B F C A


### 5.3 연습문제
#### 문제 
- 첫 줄에는 트리의 정점의 총 수 V, 그 다음 줄에는 V-1개 간선 정보가 나열됩니다.
- 간선은 그것을 이루는 두 정점으로 표기됩니다.
- 간선은 항상 "부모 자식" 순서로 표기되며, 아래 예에서 두 번째 줄 처음 1과 2는 정점 1과 2를 잇는 간선으로 1이 부모, 2가 자식을 의미합니다.
##### input
```python
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
```

#### 코드
```python
# 전위 순회
def preorder(node):
    if node != 0:
        # 나를 출력
        print(node, end=' ')
        # 왼쪽 자식을 조사
        preorder(left[node])
        # 오른쪽 자식을 조사
        preorder(right[node])


# 중위 순회
def inorder(node):
    if node != 0:
        # 왼쪽 자식을 조사
        inorder(left[node])
        print(node, end=' ')
        # 오른쪽 자식을 조사
        inorder(right[node])

# 후위 순회
def postorder(node):
    if node != 0:
        # 왼쪽 자식을 조사
        postorder(left[node])
        # 오른쪽 자식을 조사
        postorder(right[node])
        print(node, end=' ')


V = int(input())  # 정점 개수
E = V -1  # 간선 개수
arr = list(map(int, input().split()))

# 인덱스를 활용할 것이기 때문에 노드의 개수 +1
# 0번 노드는 없음
parent = [0] * (V+1)  # 부모의 정보
left = [0] * (V+1)  # 왼쪽 자식 정보
right = [0] * (V+1)  # 오른쪽 자식 정보

for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    # print(p, c)
    if left[p] == 0:  # 아직 왼쪽 자식이 없으면
        left[p] = c  # p번의 외쪽 자식 c
    else:
        right[p] = c
    parent[c] = p

root = 0
for i in range(1, V+1):  # 모든 노드 순회
    # 부모정보를 담았는데, 부모가 없으면 루트
    if parent[i] == 0:
        root = i
        break

# 조사를 시작 root 노드부터
print('---전위 순회---')
preorder(root)
print()
print('---중위 순회---')
inorder(root)
print()
print('---후위 순회---')
postorder(root)
```
------------------------------------------------------------------------

## 6. 이진 트리 표현 방법

### 6.1 배열 이용

-   노드 번호 규칙 (1-based index)
    -   부모(i)의 왼쪽 자식 = 2i
    -   부모(i)의 오른쪽 자식 = 2i + 1
    -   부모 = i // 2
-   완전/포화 이진 트리에 적합
-   단점: 편향 트리에서는 메모리 낭비 발생

### 6.2 연결 리스트 이용

-   각 노드가 `left`, `right` 포인터를 가짐
-   동적 삽입·삭제에 유리
-   일반 트리에서는 `children` 리스트로 표현 가능

------------------------------------------------------------------------

## 7. 이진 탐색 트리 (Binary Search Tree, BST)

-   규칙
    1.  왼쪽 서브트리 값 < 루트 값
    2.  오른쪽 서브트리 값 > 루트 값
    3.  각 서브트리도 BST
-   **중위 순회** 시 오름차순으로 출력됨
-   연산 시간 복잡도
    -   평균: O(log n)
    -   최악(편향 트리): O(n)

### 7.1 연산

-   **탐색**: 루트에서 시작해 비교 → 왼/오른쪽 재귀 탐색
-   **삽입**: 탐색 실패 위치에 삽입
-   **삭제**:
    -   단말 노드 → 바로 삭제
    -   하나의 자식만 → 자식으로 대체
    -   두 개의 자식 → 왼쪽 서브트리의 최대값(또는 오른쪽 서브트리
        최소값)으로 대체

------------------------------------------------------------------------

## 8. 수식 트리 (Expression Tree)

-   연산자 → 루트/내부 노드
-   피연산자 → 리프 노드
-   순회 방법에 따라 다른 수식 표현 가능
    -   전위: prefix 표기법
    -   중위: 일반 수식
    -   후위: postfix 표기법
